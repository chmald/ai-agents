"""Action functions for the coding agent."""

import logging
import sys
import os
from typing import Dict, Any, List

# Add parent directories to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

from actions.gitlab import create_merge_request as gitlab_create_mr, commit_code_changes

logger = logging.getLogger(__name__)


async def analyze_code(repo: str, branch: str) -> Dict[str, Any]:
    """Analyze code repository structure and identify areas for improvement.
    
    Args:
        repo: Repository name in format 'owner/name'
        branch: Branch to analyze
        
    Returns:
        Analysis results including file structure, patterns, and recommendations
    """
    try:
        # Mock analysis for demo - in production this would:
        # 1. Clone the repository
        # 2. Analyze code structure
        # 3. Identify patterns and issues
        # 4. Generate recommendations
        
        analysis = {
            "repository": repo,
            "branch": branch,
            "summary": f"Analyzed repository {repo} on branch {branch}",
            "files_analyzed": 15,
            "languages_detected": ["Python", "JavaScript", "Docker"],
            "patterns_found": [
                "REST API endpoints",
                "Database models",
                "Configuration files"
            ],
            "recommendations": [
                "Add comprehensive error handling",
                "Implement input validation",
                "Add unit tests for new features",
                "Update documentation"
            ],
            "complexity_score": 6.5,
            "maintainability": "Good"
        }
        
        logger.info(f"Code analysis completed for {repo}")
        return analysis
        
    except Exception as e:
        logger.error(f"Code analysis failed: {e}")
        return {
            "repository": repo,
            "branch": branch,
            "summary": f"Analysis failed: {str(e)}",
            "error": str(e)
        }


async def generate_code(requirements: str, analysis: Dict[str, Any]) -> List[Dict[str, str]]:
    """Generate code files based on requirements and analysis.
    
    Args:
        requirements: Code requirements description
        analysis: Previous code analysis results
        
    Returns:
        List of file changes with path, content, and action
    """
    try:
        logger.info("Generating code files")
        
        # Generate sample files based on requirements
        files = []
        
        # Generate a Python module
        if "python" in requirements.lower() or "Python" in analysis.get("languages_detected", []):
            files.append({
                "file_path": "src/generated_module.py",
                "content": f'''"""
Generated module based on requirements: {requirements[:100]}...

This module was automatically generated by the AI Coding Agent.
"""

import logging
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)


class GeneratedClass:
    """Generated class implementing the requirements."""
    
    def __init__(self):
        """Initialize the generated class."""
        self.initialized = True
        logger.info("GeneratedClass initialized")
    
    def process_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Process data according to requirements.
        
        Args:
            data: Input data to process
            
        Returns:
            Processed data
        """
        try:
            # Basic processing logic
            result = {{
                "input": data,
                "processed": True,
                "timestamp": "2024-01-01T00:00:00Z",
                "requirements": "{requirements[:50]}..."
            }}
            
            logger.info("Data processed successfully")
            return result
            
        except Exception as e:
            logger.error(f"Processing failed: {{e}}")
            raise
    
    def validate_input(self, data: Any) -> bool:
        """Validate input data.
        
        Args:
            data: Data to validate
            
        Returns:
            True if valid, False otherwise
        """
        if data is None:
            return False
        
        if isinstance(data, dict):
            return len(data) > 0
        
        return True


def main():
    """Main function for testing the generated module."""
    generator = GeneratedClass()
    
    test_data = {{"test": "data", "requirements": "{requirements[:30]}..."}}
    
    if generator.validate_input(test_data):
        result = generator.process_data(test_data)
        print(f"Result: {{result}}")
    else:
        print("Invalid input data")


if __name__ == "__main__":
    main()
''',
                "action": "create"
            })
        
        # Generate configuration file
        files.append({
            "file_path": "config/generated_config.yaml",
            "content": f'''# Generated configuration file
# Based on requirements: {requirements[:100]}...

app:
  name: "AI Generated Application"
  version: "1.0.0"
  debug: false

features:
  auto_generated: true
  requirements_based: true
  
database:
  host: "localhost"
  port: 5432
  name: "generated_db"
  
api:
  host: "0.0.0.0"
  port: 8080
  timeout: 30

logging:
  level: "INFO"
  format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
''',
            "action": "create"
        })
        
        # Generate test file
        files.append({
            "file_path": "tests/test_generated_module.py",
            "content": f'''"""
Tests for generated module.

Generated based on requirements: {requirements[:100]}...
"""

import unittest
from src.generated_module import GeneratedClass


class TestGeneratedClass(unittest.TestCase):
    """Test cases for GeneratedClass."""
    
    def setUp(self):
        """Set up test fixtures."""
        self.generator = GeneratedClass()
    
    def test_initialization(self):
        """Test class initialization."""
        self.assertTrue(self.generator.initialized)
    
    def test_process_data_valid_input(self):
        """Test data processing with valid input."""
        test_data = {{"key": "value"}}
        result = self.generator.process_data(test_data)
        
        self.assertIsInstance(result, dict)
        self.assertTrue(result["processed"])
        self.assertEqual(result["input"], test_data)
    
    def test_validate_input_valid_dict(self):
        """Test input validation with valid dictionary."""
        valid_data = {{"test": "data"}}
        self.assertTrue(self.generator.validate_input(valid_data))
    
    def test_validate_input_empty_dict(self):
        """Test input validation with empty dictionary."""
        empty_data = {{}}
        self.assertFalse(self.generator.validate_input(empty_data))
    
    def test_validate_input_none(self):
        """Test input validation with None."""
        self.assertFalse(self.generator.validate_input(None))


if __name__ == "__main__":
    unittest.main()
''',
            "action": "create"
        })
        
        # Generate README
        files.append({
            "file_path": "GENERATED_README.md",
            "content": f'''# AI Generated Implementation

This code was automatically generated by the AI Coding Agent based on the following requirements:

## Requirements
{requirements}

## Generated Files
- `src/generated_module.py` - Main implementation module
- `config/generated_config.yaml` - Configuration file  
- `tests/test_generated_module.py` - Unit tests
- `GENERATED_README.md` - This documentation

## Repository Analysis Summary
- **Repository**: {analysis.get("repository", "Unknown")}
- **Branch**: {analysis.get("branch", "Unknown")}
- **Files Analyzed**: {analysis.get("files_analyzed", 0)}
- **Languages**: {", ".join(analysis.get("languages_detected", []))}
- **Complexity Score**: {analysis.get("complexity_score", "N/A")}

## Usage

```python
from src.generated_module import GeneratedClass

# Initialize the generated class
generator = GeneratedClass()

# Process some data
data = {{"example": "data"}}
if generator.validate_input(data):
    result = generator.process_data(data)
    print(result)
```

## Testing

Run the generated tests:

```bash
python -m pytest tests/test_generated_module.py
```

## Configuration

Update the configuration in `config/generated_config.yaml` as needed.

## Notes

This implementation is generated based on the provided requirements and may need manual refinement for production use.
Please review and test thoroughly before deployment.
''',
            "action": "create"
        })
        
        logger.info(f"Generated {len(files)} code files")
        return files
        
    except Exception as e:
        logger.error(f"Code generation failed: {e}")
        return []


async def create_merge_request(
    repo: str, 
    branch: str, 
    title: str, 
    description: str,
    files: List[Dict[str, str]]
) -> str:
    """Create a merge request with generated code.
    
    Args:
        repo: Repository name
        branch: Source branch name
        title: MR title
        description: MR description
        files: List of file changes
        
    Returns:
        Merge request URL
    """
    try:
        # First commit the files to the branch
        if files:
            commit_url = await commit_code_changes(repo, branch, files)
            logger.info(f"Files committed: {commit_url}")
        
        # Create merge request
        mr_url = await gitlab_create_mr(repo, branch, title, description)
        logger.info(f"Merge request created: {mr_url}")
        
        return mr_url
        
    except Exception as e:
        logger.error(f"Failed to create merge request: {e}")
        # Return a mock URL for demo purposes
        return f"https://gitlab.com/{repo}/-/merge_requests/demo-{hash(branch) % 1000}"