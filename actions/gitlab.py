"""GitLab API integration for code management."""

import os
import logging
from typing import Dict, Any, Optional, List
import httpx

logger = logging.getLogger(__name__)


class GitLabClient:
    """GitLab API client for repository operations."""
    
    def __init__(self):
        self.base_url = os.getenv("GITLAB_URL", "https://gitlab.com/api/v4")
        self.token = os.getenv("GITLAB_TOKEN")
        self.headers = {
            "Authorization": f"Bearer {self.token}",
            "Content-Type": "application/json"
        } if self.token else {}
    
    async def create_merge_request(
        self, 
        project_id: str, 
        source_branch: str, 
        target_branch: str = "main",
        title: str = "Automated code changes",
        description: str = "Generated by AI coding agent"
    ) -> Dict[str, Any]:
        """Create a merge request.
        
        Args:
            project_id: GitLab project ID
            source_branch: Source branch name
            target_branch: Target branch name
            title: MR title
            description: MR description
            
        Returns:
            Merge request data
        """
        if not self.token:
            logger.warning("GITLAB_TOKEN not set, returning mock response")
            return {
                "id": 12345,
                "web_url": f"https://gitlab.com/demo/demo/-/merge_requests/12345",
                "title": title,
                "state": "opened"
            }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.base_url}/projects/{project_id}/merge_requests",
                    headers=self.headers,
                    json={
                        "source_branch": source_branch,
                        "target_branch": target_branch,
                        "title": title,
                        "description": description
                    }
                )
                response.raise_for_status()
                return response.json()
        except Exception as e:
            logger.error(f"Failed to create MR: {e}")
            raise
    
    async def create_branch(self, project_id: str, branch_name: str, ref: str = "main") -> Dict[str, Any]:
        """Create a new branch.
        
        Args:
            project_id: GitLab project ID
            branch_name: New branch name
            ref: Reference to branch from
            
        Returns:
            Branch data
        """
        if not self.token:
            logger.warning("GITLAB_TOKEN not set, returning mock response")
            return {
                "name": branch_name,
                "commit": {"id": "abc123", "message": "Latest commit"}
            }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.base_url}/projects/{project_id}/repository/branches",
                    headers=self.headers,
                    json={
                        "branch": branch_name,
                        "ref": ref
                    }
                )
                response.raise_for_status()
                return response.json()
        except Exception as e:
            logger.error(f"Failed to create branch: {e}")
            raise
    
    async def commit_files(
        self, 
        project_id: str, 
        branch_name: str,
        files: List[Dict[str, str]],
        commit_message: str = "AI-generated code changes"
    ) -> Dict[str, Any]:
        """Commit files to a branch.
        
        Args:
            project_id: GitLab project ID
            branch_name: Target branch
            files: List of file changes with 'action', 'file_path', 'content'
            commit_message: Commit message
            
        Returns:
            Commit data
        """
        if not self.token:
            logger.warning("GITLAB_TOKEN not set, returning mock response")
            return {
                "id": "def456",
                "message": commit_message,
                "web_url": f"https://gitlab.com/demo/demo/-/commit/def456"
            }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.base_url}/projects/{project_id}/repository/commits",
                    headers=self.headers,
                    json={
                        "branch": branch_name,
                        "commit_message": commit_message,
                        "actions": files
                    }
                )
                response.raise_for_status()
                return response.json()
        except Exception as e:
            logger.error(f"Failed to commit files: {e}")
            raise


# Default client instance
gitlab_client = GitLabClient()


async def create_merge_request(
    repo: str, 
    branch: str, 
    title: str = "Automated code changes",
    description: str = "Generated by AI coding agent"
) -> str:
    """Create a merge request for the given repository.
    
    Args:
        repo: Repository in format 'owner/name'
        branch: Source branch name
        title: MR title
        description: MR description
        
    Returns:
        Merge request URL
    """
    # Extract project ID from repo format
    project_id = repo.replace("/", "%2F")
    
    mr_data = await gitlab_client.create_merge_request(
        project_id=project_id,
        source_branch=branch,
        title=title,
        description=description
    )
    
    return mr_data.get("web_url", "")


async def commit_code_changes(repo: str, branch: str, files: List[Dict[str, str]]) -> str:
    """Commit code changes to a repository branch.
    
    Args:
        repo: Repository in format 'owner/name'
        branch: Target branch name
        files: List of file changes
        
    Returns:
        Commit URL
    """
    project_id = repo.replace("/", "%2F")
    
    commit_data = await gitlab_client.commit_files(
        project_id=project_id,
        branch_name=branch,
        files=files
    )
    
    return commit_data.get("web_url", "")